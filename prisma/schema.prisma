generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider     = "postgresql"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

enum UserStatus {
  ONLINE
  IDLE
  DND
  INVISIBLE
  OFFLINE
}

enum PermissionType {
  // Server Management
  ADMINISTRATOR
  MANAGE_SERVER
  MANAGE_CHANNELS
  MANAGE_ROLES
  MANAGE_EMOJIS
  VIEW_AUDIT_LOG
  VIEW_GUILD_INSIGHTS
  MANAGE_WEBHOOKS
  MANAGE_GUILD
  
  // Member Management
  KICK_MEMBERS
  BAN_MEMBERS
  TIMEOUT_MEMBERS
  MANAGE_NICKNAMES
  CHANGE_NICKNAME
  
  // Text & Voice Permissions
  VIEW_CHANNELS
  SEND_MESSAGES
  SEND_TTS_MESSAGES
  MANAGE_MESSAGES
  EMBED_LINKS
  ATTACH_FILES
  READ_MESSAGE_HISTORY
  MENTION_EVERYONE
  USE_EXTERNAL_EMOJIS
  ADD_REACTIONS
  
  // Voice Permissions
  CONNECT
  SPEAK
  MUTE_MEMBERS
  DEAFEN_MEMBERS
  MOVE_MEMBERS
  USE_VAD
  PRIORITY_SPEAKER
  
  // Stage Permissions
  REQUEST_TO_SPEAK
  MANAGE_STAGE
  
  // Advanced Permissions
  CREATE_INSTANT_INVITE
  USE_SLASH_COMMANDS
  USE_APPLICATION_COMMANDS
  SEND_MESSAGES_IN_THREADS
  CREATE_PUBLIC_THREADS
  CREATE_PRIVATE_THREADS
  MANAGE_THREADS
  USE_EXTERNAL_STICKERS
  SEND_VOICE_MESSAGES
}

enum PermissionGrantType {
  ALLOW
  DENY
  INHERIT
}

enum PermissionScope {
  SERVER
  CHANNEL
  CATEGORY
  THREAD
}

model Profile {
  id         String  @id @default(uuid())
  userId     String  @unique
  name       String
  globalName String?
  imageUrl   String  @db.Text
  email      String  @db.Text
  customCss  String?

  servers  Server[]
  members  Member[]
  channels Channel[]

  // Conversation relations for profile-based messaging
  conversationMembers ConversationMember[]
  directMessages      DirectMessage[]

  // Notification relations
  notifications          Notification[]
  triggeredNotifications Notification[] @relation("NotificationTriggeredBy")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  status     UserStatus  @default(OFFLINE)
  prevStatus UserStatus?

  bio            String?
  presenceStatus String?
  pronouns       String?
  bannerUrl      String?

  // Friend management settings
  allowNonFriendDMs Boolean @default(true)
  friendRequestPrivacy String @default("everyone") // "everyone", "friends-of-friends", "none"

  // Friend relations
  sentFriendRequests     Friendship[] @relation("FriendshipRequester")
  receivedFriendRequests Friendship[] @relation("FriendshipReceiver")
  sentBlocks             Block[]      @relation("BlockRequester")
  receivedBlocks         Block[]      @relation("BlockReceiver")
  
  // Ban relations
  bansReceived Ban[]
  bansGiven    Ban[] @relation("BannedBy")
}

model Server {
  id         String @id @default(uuid())
  name       String
  imageUrl   String @db.Text
  inviteCode String @unique

  profileId String
  profile   Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  members    Member[]
  channels   Channel[]
  categories Category[]

  // New permission system relations
  roles              Role[]
  permissionAuditLogs PermissionAuditLog[]
  
  // Ban records for this server
  bans Ban[]

  // Notification relation
  notifications Notification[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([profileId])
}

enum MemberRole {
  ADMIN
  MODERATOR
  GUEST
}

model Member {
  id   String     @id @default(uuid())
  role MemberRole @default(GUEST)

  profileId String
  profile   Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  serverId String
  server   Server @relation(fields: [serverId], references: [id], onDelete: Cascade)

  messages       Message[]
  directMessages DirectMessage[]

  // For group conversations
  conversationMembers ConversationMember[]

  // Add the missing opposite relation field for Conversation creator
  createdConversations Conversation[] @relation("ConversationCreator")

  // New permission system relations
  memberRoles       MemberRoleAssignment[]
  userPermissions   UserPermission[]
  channelPermissions ChannelPermission[]
  categoryPermissions CategoryPermission[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([profileId])
  @@index([serverId])
}

enum ChannelType {
  TEXT
  AUDIO
  VIDEO
  STAGE
  ANNOUNCEMENT
}

model Category {
  id       String    @id @default(uuid())
  name     String
  position Int       @default(0)
  channels Channel[]
  Server   Server?   @relation(fields: [serverId], references: [id])
  serverId String?
  
  // Permission system relations
  categoryPermissions CategoryPermission[]
}

model Channel {
  id   String      @id @default(uuid())
  name String
  type ChannelType @default(TEXT)

  profileId String
  profile   Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  serverId String
  server   Server @relation(fields: [serverId], references: [id], onDelete: Cascade)

  messages Message[]

  // Notification relation
  notifications Notification[]
  
  // Permission system relations
  channelPermissions ChannelPermission[]

  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  Category   Category? @relation(fields: [categoryId], references: [id])
  categoryId String?
  position   Int

  @@index([profileId])
  @@index([serverId])
}

model Attachment {
  id   String  @id @default(uuid())
  utId String
  name String
  url  String
  size Int?
  type String?

  // Can be attached to either channel messages or direct messages
  Message   Message? @relation(fields: [messageId], references: [id], onDelete: Cascade)
  messageId String?

  // Removed self-referential relation to avoid conflicts
  DirectMessage   DirectMessage? @relation(fields: [directMessageId], references: [id], onDelete: Cascade)
  directMessageId String?

  createdAt DateTime @default(now())

  @@index([messageId])
  @@index([directMessageId])
}

model Message {
  id      String @id @default(uuid())
  content String @db.Text

  attachments Attachment[]

  memberId String
  member   Member @relation(fields: [memberId], references: [id], onDelete: Cascade)

  channelId String
  channel   Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)

  deleted Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([memberId])
  @@index([channelId])
}

enum ConversationType {
  DIRECT_MESSAGE // 1-on-1 conversation
  GROUP_MESSAGE // Group conversation with multiple members
}

model Conversation {
  id   String           @id @default(uuid())
  name String? // Optional name for group conversations
  type ConversationType @default(DIRECT_MESSAGE)

  // Creator of the conversation (especially useful for groups)
  creatorId String?
  creator   Member? @relation("ConversationCreator", fields: [creatorId], references: [id], onDelete: SetNull)

  members        ConversationMember[]
  directMessages DirectMessage[]

  // Notification relation
  notifications Notification[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([creatorId])
}

model ConversationMember {
  id String @id @default(uuid())

  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  // Changed from memberId to profileId for direct profile-based conversations
  profileId String
  profile   Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  // Keep memberId as optional for server-context conversations
  memberId String?
  member   Member? @relation(fields: [memberId], references: [id], onDelete: Cascade)

  // When the member joined the conversation
  joinedAt DateTime @default(now())

  // When the member left the conversation (null if still active)
  leftAt DateTime?

  // Last time the member read messages in this conversation
  lastReadAt DateTime?

  @@unique([conversationId, profileId])
  @@index([conversationId])
  @@index([profileId])
  @@index([memberId])
}

model DirectMessage {
  id      String @id @default(uuid())
  content String @db.Text

  // Updated to use the new Attachments relationship
  attachments Attachment[]

  // Changed to work with profiles for direct messaging
  profileId String
  profile   Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  // Keep memberId as optional for server-context messages
  memberId String?
  member   Member? @relation(fields: [memberId], references: [id], onDelete: Cascade)

  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  deleted Boolean @default(false)

  // Simple reply field without self-referential relation to avoid conflicts
  replyToId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([profileId])
  @@index([memberId])
  @@index([conversationId])
  @@index([replyToId])
}

enum NotificationType {
  MESSAGE // New message in channel/DM/group
  MENTION // User was mentioned
  REPLY // Someone replied to user's message
  FRIEND_REQUEST // Friend request received
  CALL // Incoming call
  SERVER_INVITE // Server invitation
  SYSTEM // System notifications
}

model Notification {
  id      String           @id @default(uuid())
  type    NotificationType
  title   String
  content String?

  // Who this notification is for
  profileId String
  profile   Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  // Who triggered this notification (optional)
  triggeredById String?
  triggeredBy   Profile? @relation("NotificationTriggeredBy", fields: [triggeredById], references: [id], onDelete: SetNull)

  // Related entities (optional)
  serverId String?
  server   Server? @relation(fields: [serverId], references: [id], onDelete: SetNull)

  channelId String?
  channel   Channel? @relation(fields: [channelId], references: [id], onDelete: SetNull)

  conversationId String?
  conversation   Conversation? @relation(fields: [conversationId], references: [id], onDelete: SetNull)

  messageId       String?
  directMessageId String?

  // Notification state
  read   Boolean   @default(false)
  readAt DateTime?

  // For grouping related notifications
  groupKey String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([profileId])
  @@index([triggeredById])
  @@index([serverId])
  @@index([channelId])
  @@index([conversationId])
  @@index([groupKey])
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  DECLINED
  CANCELLED
}

model Friendship {
  id String @id @default(uuid())

  requesterId String
  requester   Profile @relation("FriendshipRequester", fields: [requesterId], references: [id], onDelete: Cascade)

  receiverId String
  receiver   Profile @relation("FriendshipReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  status FriendshipStatus @default(PENDING)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([requesterId, receiverId])
  @@index([requesterId])
  @@index([receiverId])
  @@index([status])
}

model Block {
  id String @id @default(uuid())

  blockerId String
  blocker   Profile @relation("BlockRequester", fields: [blockerId], references: [id], onDelete: Cascade)

  blockedId String
  blocked   Profile @relation("BlockReceiver", fields: [blockedId], references: [id], onDelete: Cascade)

  reason String?

  createdAt DateTime @default(now())

  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
}

// Custom Roles System
model Role {
  id          String @id @default(uuid())
  name        String
  color       String?
  position    Int    @default(0)
  hoisted     Boolean @default(false)
  mentionable Boolean @default(false)
  
  serverId String
  server   Server @relation(fields: [serverId], references: [id], onDelete: Cascade)
  
  // Permission assignments
  permissions RolePermission[]
  
  // Members with this role
  memberRoles MemberRoleAssignment[]
  
  // Channel and category overrides
  channelPermissions ChannelPermission[]
  categoryPermissions CategoryPermission[]
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([serverId])
  @@index([position])
}

// Role Permission mapping
model RolePermission {
  id String @id @default(uuid())
  
  roleId String
  role   Role @relation(fields: [roleId], references: [id], onDelete: Cascade)
  
  permission PermissionType
  scope      PermissionScope
  grant      PermissionGrantType @default(ALLOW)
  
  // Optional target IDs for scoped permissions
  targetId String? // Can be channelId, categoryId, etc.
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([roleId, permission, scope, targetId])
  @@index([roleId])
  @@index([permission])
}

// Member Role assignments (many-to-many)
model MemberRoleAssignment {
  id String @id @default(uuid())
  
  memberId String
  member   Member @relation(fields: [memberId], references: [id], onDelete: Cascade)
  
  roleId String
  role   Role @relation(fields: [roleId], references: [id], onDelete: Cascade)
  
  assignedAt DateTime @default(now())
  assignedBy String? // Profile ID of who assigned this role
  
  @@unique([memberId, roleId])
  @@index([memberId])
  @@index([roleId])
}

// User-specific permission overrides
model UserPermission {
  id String @id @default(uuid())
  
  memberId String
  member   Member @relation(fields: [memberId], references: [id], onDelete: Cascade)
  
  permission PermissionType
  scope      PermissionScope
  grant      PermissionGrantType
  
  // Optional target IDs for scoped permissions
  targetId String? // Can be channelId, categoryId, etc.
  
  // Metadata
  reason     String?
  assignedBy String  // Profile ID of who assigned this permission
  expiresAt  DateTime?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([memberId, permission, scope, targetId])
  @@index([memberId])
  @@index([permission])
}

// Channel-specific permission overrides
model ChannelPermission {
  id String @id @default(uuid())
  
  channelId String
  channel   Channel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  
  // Can be for a role or a specific member
  roleId   String?
  role     Role?   @relation(fields: [roleId], references: [id], onDelete: Cascade)
  
  memberId String?
  member   Member? @relation(fields: [memberId], references: [id], onDelete: Cascade)
  
  permission PermissionType
  grant      PermissionGrantType
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([channelId, roleId, memberId, permission])
  @@index([channelId])
  @@index([roleId])
  @@index([memberId])
}

// Category-specific permission overrides
model CategoryPermission {
  id String @id @default(uuid())
  
  categoryId String
  category   Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  
  // Can be for a role or a specific member
  roleId   String?
  role     Role?   @relation(fields: [roleId], references: [id], onDelete: Cascade)
  
  memberId String?
  member   Member? @relation(fields: [memberId], references: [id], onDelete: Cascade)
  
  permission PermissionType
  grant      PermissionGrantType
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([categoryId, roleId, memberId, permission])
  @@index([categoryId])
  @@index([roleId])
  @@index([memberId])
}

// Audit log for permission changes
model PermissionAuditLog {
  id String @id @default(uuid())
  
  serverId String
  server   Server @relation(fields: [serverId], references: [id], onDelete: Cascade)
  
  action     String // "ROLE_CREATED", "PERMISSION_GRANTED", etc.
  targetType String // "ROLE", "MEMBER", "CHANNEL", etc.
  targetId   String
  
  permission PermissionType?
  oldValue   String? // JSON of old permission state
  newValue   String? // JSON of new permission state
  
  performedBy String // Profile ID
  reason      String?
  
  createdAt DateTime @default(now())
  
  @@index([serverId])
  @@index([targetType, targetId])
  @@index([performedBy])
  @@index([createdAt])
}

// Server ban records
model Ban {
  id String @id @default(uuid())
  
  serverId String
  server   Server @relation(fields: [serverId], references: [id], onDelete: Cascade)
  
  profileId String
  profile   Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  
  bannedById String
  bannedBy   Profile @relation("BannedBy", fields: [bannedById], references: [id], onDelete: Cascade)
  
  reason    String?
  createdAt DateTime @default(now())
  
  @@unique([serverId, profileId])
  @@index([serverId])
  @@index([profileId])
  @@index([bannedById])
}
